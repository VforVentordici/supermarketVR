<html>
  <head>
    <title>A Threejs Scene</title>
    <style>
        body {
      /* set margin to 0 and overflow to hidden, to go fullscreen */
      margin: 0;
      overflow: hidden;
      background-color: #264A60;  /*BLUE 70
      /*background: #cefffa;
      background: -moz-linear-gradient(top,  #cefffa 0%, #f2b51d 89%);
      background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#cefffa), color-stop(89%,#f2b51d));
      background: -webkit-linear-gradient(top,  #cefffa 0%,#f2b51d 89%);
      background: -o-linear-gradient(top,  #cefffa 0%,#f2b51d 89%);
      background: -ms-linear-gradient(top,  #cefffa 0%,#f2b51d 89%);
      background: linear-gradient(to bottom,  #cefffa 0%,#f2b51d 89%);
      filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#cefffa', endColorstr='#f2b51d',GradientType=0 );*/
      }
    </style>
  </head>
  <body>
    <script type="text/javascript" src="js/three.min.js"></script>
    <script type="text/javascript" src="js/tween.min.js"></script>
    <script type="text/javascript" src="js/ParticleEngine.js"></script>
    <script type="text/javascript" src="js/stats.min.js"></script>
    <script type="text/javascript" src="js/FirstPersonControls.js"></script>
    <script type="text/javascript" src="js/JSONLoader.js"></script>
    <script type="text/javascript" src="js/OculusRiftEffect.js"></script>
    <script type="text/javascript" src="js/PathCamera.js"></script>
    <script type="text/javascript" src="js/DK2Controls.js"></script>
    <script type="text/javascript">

      //Global variables
      var container;

      var textContainer;

      var scene,renderer,controls;
      var camera,pathCamera;
      var path;
      var step = 0;         // camera step
      var scene_mesh;
      var sphere_material,sphere_geometry;
      var light,loader;
      var oculusRenderer;
      var clock = new THREE.Clock();

      var pathEnabled = true; //true for runner camera
      var oculusEnabled = false;

      // is it raining?
      var isRaining = true;
      var rain;

      var cube;
      var isTweening = false;

      function init() {

      container = document.createElement('div');
      document.body.appendChild(container);

      clock = new THREE.Clock();
      // create a scene, that will hold all our elements such as objects, cameras and lights.

      /*************************
                SCENE
      *************************/
      scene = new THREE.Scene();

      //add particle system for raining
      rain = new ParticleEngine();
      if(isRaining)
        rain.start();

      //add track
      var sampleClosedSpline = new THREE.ClosedSplineCurve3([
            new THREE.Vector3(0, -40, -40),
            new THREE.Vector3(0, 40, -40),
            new THREE.Vector3(0, 140, -40),
            new THREE.Vector3(0, 40, 40),
            new THREE.Vector3(0, -40, 40),
          ]);
      // sampleClosedSpline.rotation.z = Math.PI;
      
      pathCamera = new THREE.PerspectiveCamera( 84, window.innerWidth / window.innerHeight, 0.01, 1000 );
      path = new PathCamera(pathCamera,sampleClosedSpline);
      var curveGeometry = new THREE.TubeGeometry(sampleClosedSpline, 200, 1, 1, true); //true == closed curve
      var pathMesh = new THREE.Mesh(curveGeometry,
                new THREE.LineBasicMaterial( { color : 0xff0000 } ));
      scene.add(pathMesh);

      // create a camera, which defines where we're looking at.
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 30);


      // create a render, sets the background color and the size
      renderer = new THREE.WebGLRenderer({antialias:true,alpha: true});
      renderer.setClearColor( 0xa7fae6, 1 );
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMapEnabled = true;

      // Here is the oculusRenderer for the Oculus Rift
        // worldScale 100 means that 100 Units == 1m
      oculusRenderer = new THREE.OculusRiftEffect( renderer, {worldScale: 100} );
      oculusRenderer.setSize( window.innerWidth, window.innerHeight );

      //Create a light
      light = new THREE.SpotLight(0xffa573);
      light.position.set(0,10,50);
      light.shadowCameraNear = 50;
      light.shadowMapWidth = 1024;
      light.shadowMapHeight = 1024;
      light.shadowCameraFar = 5000;
      light.castShadow = true;
      scene.add(light);




       var cubeGeometry = new THREE.CubeGeometry(1, 1, 1);
       var cubeMaterial = new THREE.MeshLambertMaterial({
         color: "red"
       });
       cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
       cube.castShadow = true;
       cube.position.z = -5;
       cube.position.y = 1;
       cube.position.x = 3;
       scene.add(cube);

      // add fog
      scene.fog = new THREE.FogExp2( 0xFFFFFF, 0.15);

      // var ambientLight = new THREE.AmbientLight( 0xffa573 ); // soft white light
      var ambientLight = new THREE.AmbientLight( 0x5596E6 );
      scene.add(ambientLight );

      // load scene model
      loader = new THREE.JSONLoader();
      loadScene();

      // position and point the default camera to the center of the scene
      camera.position.x = 0;
      camera.position.y = 1;
      camera.position.z = 0;

      // Oculus DK2 controls

      if(oculusEnabled == true)
      controls = new THREE.DK2Controls(pathEnabled === true? pathCamera:camera);
      else{
        controls = new THREE.FirstPersonControls( pathEnabled === true? pathCamera:camera);
        controls.movementSpeed = 2;
        controls.lookSpeed = 0.02;
        controls.lookVertical = true;  
      }

      // // add fps stats
      addStats();

      // add the output of the renderer to the html element
      container.appendChild(renderer.domElement);

      // call the render function, after the first render, interval is determined
      // by requestAnimationFrame
      render(0.016);
    }

    
      function render(dt) {
        var delta = clock.getDelta();

        if(!pathEnabled && !oculusEnabled)
          controls.update( delta ); 

        renderer.autoClear = false;
        // step +=2;
        // path.update(step);
        TWEEN.update();

        // update rain
        rain.update(dt);

        //oculus rift
        if(oculusEnabled == true)
          oculusRenderer.render( scene, pathEnabled === true? pathCamera:camera);
        else
          renderer.render(scene,pathEnabled === true? pathCamera:camera);
        requestAnimationFrame( render ); 
        stats.update();
        
      }

      function addStats(){
        stats = new Stats();
        stats.setMode(0);
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.left = '0px';
        stats.domElement.style.top = '0px';
        container.appendChild(stats.domElement);
      }

      //load the scene
      function loadScene(){
          loader.load("./models/scene.js",
          function(model,materials){
            scene_mesh = new THREE.Mesh(model,new THREE.MeshFaceMaterial( materials ));
            scene_mesh.name = 'scene';
            scene_mesh.rotation.y = Math.PI;
            scene_mesh.receiveShadow = true;
            scene_mesh.castShadow = true;
            scene.add(scene_mesh);
          });
      }
            /**
       * Function handles the resize event. This make sure the camera and the renderer
       * are updated at the correct moment.
       */
      function handleResize() {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          oculusRenderer.setSize( window.innerWidth, window.innerHeight );
          renderer.setSize(window.innerWidth, window.innerHeight);
      }


      function onKeyDown ( event ) {

        //event.preventDefault();

        switch ( event.keyCode ) {

          case 38: /*up*/
          case 87: /*W*/ 
            path.takeStepForward(step,step+20, 800);
            step += 20;
            //update path
            // path.update(step);
          break;

          case 37: /*left*/
          case 65: /*A*/  break;

          case 40: /*down*/
          case 83: /*S*/ 
            step -= 20; 
            //update path
            path.update(step);
          break;

          case 39: /*right*/
          case 68: /*D*/  break;

        }
      };

      function onKeyUp( event ) {
        switch( event.keyCode ) {

          case 38: /*up*/
          case 87: /*W*/  break;

          case 37: /*left*/
          case 65: /*A*/  break;

          case 40: /*down*/
          case 83: /*S*/  break;

          case 39: /*right*/
          case 68: /*D*/  break;

        }
      };

      function takeStepForward(cube, start, end, time) {

        console.log('Hello Cube!');
        var widht = 4;
        var cubeGeometry = cube.geometry;

        if (!isTweening) {
            var tween = new TWEEN.Tween( { x: start, cube: cube, previous: 0} )
                    .to( { x: end }, time )
                    .easing(TWEEN.Easing.Elastic.InOut)
                    .onStart( function() {
                        isTweening = true;
                        cube.position.y+=-widht/2;
                        cube.position.x+=-widht/2;
                        cubeGeometry.applyMatrix(new THREE.Matrix4().makeTranslation( widht/2,  widht/2, 0 ) );
                    })
                    .onUpdate( function () {
                        cube.geometry.applyMatrix( new THREE.Matrix4().makeRotationZ( (this.x-this.previous) ) );

                        cube.geometry.verticesNeedUpdate=true;
                        cube.geometry.normalsNeedUpdate = true;

                        cube.previous = this.x;
                        this.previous = this.x;
                    } )
                    .onComplete(function() {
                        cube.position.y+=widht/2;
                        cube.position.x+=-widht/2;
                        cubeGeometry.applyMatrix(new THREE.Matrix4().makeTranslation( widht/2, -widht/2, 0 ) );

                        cube.position.x=Math.round(cube.position.x);
                        cube.position.y=Math.round(cube.position.y);
                        cube.position.z=Math.round(cube.position.z);

                        isTweening = false;
                    })
                    .start();
        }
    }

      window.onload = init;
      // calls the handleResize function when the window is resized
      window.addEventListener( 'keydown', onKeyDown , false );
      window.addEventListener( 'keyup', onKeyUp , false );
      window.addEventListener('resize', handleResize, false);

    </script>
  </body>
</html>




