<html>
  <head>
    <title>A Threejs Scene</title>
    <style>
       
      body {
        margin: 0;
        overflow: hidden;
      }

    </style>

  </head>

  <body>
    
    <script type="text/javascript" src="js/three.min.js"></script>
    <script type="text/javascript" src="js/stats.min.js"></script>
    <script type="text/javascript" src="js/JSONLoader.js"></script>
    <script type="text/javascript" src="js/OculusRiftEffect_HUD.js"></script>
    <script type="text/javascript" src="js/DK2Controls.js"></script>
    <script type="text/javascript" src="js/HUD.js"></script>
    <script type="text/javascript" src="js/LOLCollision.js"></script>
    <script src="js/socket.io.js"></script>
    <script type="text/javascript">

      var socket = io.connect('http://localhost:8001');
      var roll,pitch,yaw;
      var raw = {};
      var stepCount = 0;

      //Global variables.

      // body components
      var container, content;

      var ARTIFICIAL_LIGHT = 0xffffff;

      var scene, renderer, controls;
      var camera;
      var HUDscene, HUDcamera;

      var oculusEnabled = true;

      // scene scale
      var sceneX, sceneZ;
      var mapX, mapY;

      // hud elments
      var HUD;
      var HUDEnabled = false; //  if false, the HUD has to be hided
      var HUDisVisible = true; // tells if the HUD is visible or not in a partilculare moment

      // game state
      var pause = false;

      var scene_mesh,cart_mesh;
      var light;
      var ambientLightColor = ARTIFICIAL_LIGHT;

      var loader;
      var oculusRenderer;
      var clock = new THREE.Clock();
      var delta;

      var walkingFactor = 1;
      var MOVE_FACTOR = 2;

      // var cube;

      var stats;

      var collision;

      var rdy = false;
      // var enableCollision = true;


      /* NEUROSKY DATA */ 
      // @by Filippo Lo Bue
      var neurosky_position = {};
      var cube;
      var min_att_cube = [60,80];
      var min_med_cube = [60,80];
      var y_cube_offset_att = 2;
      var y_cube_offset_med = 3;
      var neurosky_flag = true;
      var ccubes = new THREE.Object3D();  
      /*****************/


      function init() {

      // creating body
      // ---------------------------------------------

      container = document.createElement('div');
      container.id = "container";

      content = document.createElement('div');
      content.id = "content";
      
      container.appendChild(content);

      document.body.appendChild(container);

      // ---------------------------------------------

      window.onkeydown = function(e) {
          var key = e.keyCode ? e.keyCode : e.which;

      }

      window.onkeyup = function(e) {
          var key = e.keyCode ? e.keyCode : e.which;

          // 27 = esc
          if (key == 27) {
            if(pause) 
              pause = false;
            else
              pause = true;
          }

          // 67 = c
          if(key == 67) {
            
          }

          // 79 = o
          if (key == 79) {
            oculusEnabled = oculusEnabled ? false : true;
            setControls();
          }

          // 72 = h
          if (key == 72) {
            HUDEnabled = HUDEnabled ? false : true;
          }


          //78 = n
          if (key == 78){
            neurosky_flag = neurosky_flag ? false : true;
            if (!neurosky_flag) {
              ccubes.traverse( function ( object ) { object.visible = false; } );
              // THREE.SceneUtils.traverseHierarchy( ccubes, function ( object ) { object.visible = false; } );
            }else{
              ccubes.traverse( function ( object ) { object.visible = true; } );
              // THREE.SceneUtils.traverseHierarchy( ccubes, function ( object ) { object.visible = true; } );
            }
          }

      }

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      scene = new THREE.Scene;

      // added LOL collisions
      collision = new LOLCollision(40);
      collision.create(10);

      // create a render, sets the background color and the size
      renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});
      renderer.setClearColor( 0xadadad, 1 );
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMapEnabled = true;

      // Here is the oculusRenderer for the Oculus Rift
        // worldScale 100 means that 100 Units == 1m
      oculusRenderer = new THREE.OculusRiftEffect( renderer, {worldScale: 100} );
      oculusRenderer.setSize( window.innerWidth, window.innerHeight );

      // create cameras.
      // camera is the normal camera and  will be controlled by FirstPersonControls.js/DK2Controls.js
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.001, 30);
      camera.position.x = 0;
      camera.position.y = 6;
      camera.position.z = 0;

      scene.add(camera);
      
      
      // --- hud
      // create a scene that will hold all hud elements and an ortho camera to always show them on top of the game scene
      HUDscene = new THREE.Scene();
      HUDcamera = new THREE.OrthographicCamera(-window.innerWidth, window.innerWidth, window.innerHeight, -window.innerHeight, 0.01, 100);

      HUD = new HUD(HUDscene, HUDisVisible, oculusEnabled);

      // lights
      light = new THREE.SpotLight(0xffa573);
      light.position.set(0, 10, 50);
      light.shadowCameraNear = 50;
      light.shadowMapWidth = 1024;
      light.shadowMapHeight = 1024;
      light.shadowCameraFar = 5000;
      light.castShadow = true;
      scene.add(light);

      var ambientLight = new THREE.AmbientLight( ambientLightColor );
      scene.add(ambientLight );

      // load scene model
      loader = new THREE.JSONLoader();
      loadScene();

      // debug controls
      setControls();
      // add fps stats
      addStats();

      // add the output of the renderer to the html element
      content.appendChild(renderer.domElement);

      // call the render function, after the first render, interval is determined by requestAnimationFrame
      render(0.016);
    }

    /* web socket */
      socket.on('data',function(data){ 

          // console.log("receiving data"); 

          if(data.pitch>0.7){
              controls.wasdqe.up = true;
              walkingFactor = data.pitch/1.8;
              controls.lookSpeed += data.yaw/400;
          }else if (data.pitch < -0.7){
              controls.wasdqe.down = true;
              walkingFactor = data.pitch/1.8;
              controls.lookSpeed += data.yaw/400;
          }
          else{
                controls.wasdqe.up = false;
                controls.wasdqe.down = false;
                walkingFactor = 0;
                controls.lookSpeed += data.yaw/15;
          }
          // console.log(controls.lookSpeed);
      });

    /* NEUROSKY HANDLER */
    socket.on('neurosky',function(data){
        console.log('Attention acquired is ' + data.eSense.attention);
        if (neurosky_flag)  //se nascondo i cubi non ne creo fino a quando non ripremo la n
        {
            if (data.eSense.attention >= min_att_cube[1]) {
              createCube(y_cube_offset_att, 0xff0000,0.8);
            }else if (data.eSense.attention >= min_att_cube[0]) {
              createCube(y_cube_offset_att, 0xff0000,0.3);
            }
            // if (data.eSense.meditation >= min_med_cube[1]) {
            //   createCube(y_cube_offset_med, 0x0000ff, 0.8);
            // }else if(data.eSense.meditation >= min_med_cube[0]){
            //   createCube(y_cube_offset_med, 0x0000ff, 0.3);
            // }
        }
      });

    function createCube(y_offset, color, opacity_value){
      cube = new THREE.Mesh(new THREE.BoxGeometry(0.5,0.5,0.5),new THREE.MeshLambertMaterial({color:'red', transparent: true, opacity: opacity_value}));
      cube.position.x=camera.position.x;
      cube.position.y=camera.position.y + y_offset;
      cube.position.z=camera.position.z;
      cube.material.color.setHex(color);
      ccubes.add(cube);
      scene.add(ccubes);
    }

    function printDirectionVector(){
      // var pLocal = new THREE.Vector3( 0, 0, -1 );
      // var pWorld = pLocal.applyMatrix4(camera.matrixWorld);
      // var dir = pWorld.sub(camera.position).normalize();
      var dir = new THREE.Vector3( 0, 0, -1 );
      dir.applyQuaternion( camera.quaternion );
      console.log('camera pos: ('+camera.position.x.toFixed(3)+','+camera.position.y.toFixed(3)+','+camera.position.z.toFixed(3)+')');
      console.log('dir vector: ('+dir.x.toFixed(3)+','+dir.y.toFixed(3)+','+dir.z.toFixed(3)+')');
    }
    /* END OF NEUROSKY HANDLER */



    function setControls() {
      // Oculus DK2 controls
        controls = new THREE.DK2Controls(camera);
    }

    function degreesToRadians(degree){
        return degree*(Math.PI/180);
    }
    
    function render(dt) {
      if(rdy) {
        // camera.updateProjectionMatrix();

        delta = clock.getDelta();
        controls.update(delta/MOVE_FACTOR);


      /* NEUROSKY UPDATE */
      neurosky_position.x = parseFloat(camera.position.x).toFixed(2);
      neurosky_position.y = parseFloat(camera.position.y).toFixed(2);
      neurosky_position.z = parseFloat(camera.position.z).toFixed(2);
      //console.log('(x,y,z) =' + '(' + neurosky_position.x+','+neurosky_position.y+','+neurosky_position.z+ ')');
      socket.emit('camera',neurosky_position);





        //lock the camera to height = 5
        camera.position.y = 8;
        // cube.position.y = 5;
        cart_mesh.position.y = 3;

        // cart_mesh.position.z = cart_mesh.position.z-1.05;
        // ---

        // update HUD
        HUD.update(pause, mapX, mapY, sceneX, sceneZ, 0, 0, oculusEnabled);

        // update
        renderer.autoClear = false;
        if(oculusEnabled == true) {
          oculusRenderer.render( scene, camera, HUDscene);
        }
        else {
          // if we just switched to the normal renderer from the oculusRenderer, we have to reset the render area size
          renderer.setSize(window.innerWidth, window.innerHeight);

          renderer.clear();
          renderer.render(scene, camera);
          renderer.render(HUDscene, HUDcamera);
        }
        stats.update();
      }
      requestAnimationFrame( render );
    }

    function addStats() {
      stats = new Stats();
      stats.setMode(0);
      stats.domElement.style.position = 'absolute';
      stats.domElement.style.left = '10px';
      stats.domElement.style.top = '10px';
      container.appendChild(stats.domElement);
    }

    //load the scene
    function loadScene() {
      loader.load("./models/market.js",
      function(model, materials) {
        scene_mesh = new THREE.Mesh( model,  new THREE.MeshFaceMaterial( materials ));
        scene_mesh.name = 'scene';
        scene_mesh.scale.x = 15;
        scene_mesh.scale.y = 15;
        scene_mesh.scale.z = 15; 
        scene_mesh.receiveShadow = true;
        scene_mesh.castShadow = true;
        scene.add(scene_mesh);
        
      });

      loader.load("./models/cart.js",
      function(model, materials) {
        cart_mesh  = new THREE.Mesh( model,  new THREE.MeshFaceMaterial( materials ), 0 ); 
        cart_mesh.name = 'cart';
        cart_mesh.scale.x = 25;
        cart_mesh.scale.y = 25;
        cart_mesh.scale.z = 25;
        cart_mesh.receiveShadow = true;
        cart_mesh.castShadow = true;

        cart_mesh.position.x = 0;
        cart_mesh.position.y = 0;
        cart_mesh.position.z = 0;
        scene.add(cart_mesh);

        rdy = true;
      });
    }
    
    /**
     * Function handles the resize event. This make sure the camera and the renderer
     * are updated at the correct moment.
     */
    function handleResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        oculusRenderer.setSize( window.innerWidth, window.innerHeight );
        renderer.setSize(window.innerWidth, window.innerHeight);
    }     

    window.onload = init;
    // calls the handleResize function when the window is resized
    window.addEventListener('resize', handleResize, false);

  </script>

  </body>
</html>