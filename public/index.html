<html>
  <head>
    <title>A Threejs Scene</title>
    <style>
       
      body {
        margin: 0;
        overflow: hidden;
      }

    </style>

  </head>

  <body>
    
    <script type="text/javascript" src="js/three.min.js"></script>
    <script type="text/javascript" src="js/stats.min.js"></script>
    <script type="text/javascript" src="js/FirstPersonControls.js"></script>
    <script type="text/javascript" src="js/JSONLoader.js"></script>
    <script type="text/javascript" src="js/OculusRiftEffect_HUD.js"></script>
    <script type="text/javascript" src="js/DK2Controls.js"></script>
    <script type="text/javascript" src="js/dat.gui.min.js"></script>
    <script type="text/javascript" src="js/HUD.js"></script>
    <script src="js/socket.io.js"></script>
    <script type="text/javascript">

      var socket = io.connect('http://localhost:8080');

      //Global variables.

      // body components
      var container, content;

      var ARTIFICIAL_LIGHT = 0xffffff;

      var scene, renderer, controls;
      var camera;
      var HUDscene, HUDcamera;

      var oculusEnabled = true;

      // scene scale
      var sceneX, sceneZ;
      var mapX, mapY;

      // hud elments
      var HUD;
      var HUDEnabled = false; //  if false, the HUD has to be hided
      var HUDisVisible = true; // tells if the HUD is visible or not in a partilculare moment

      // game state
      var pause = false;

      var scene_mesh,cart_mesh;
      var mesh;
      var light;
      var ambientLightColor = ARTIFICIAL_LIGHT;

      var loader;
      var oculusRenderer;
      var clock = new THREE.Clock();
      var delta;

      var walkingFactor = 1;
      var MOVE_FACTOR = 2;

      var cube;

      var stats;

      function init() {

      // creating body
      // ---------------------------------------------

      container = document.createElement('div');
      container.id = "container";

      content = document.createElement('div');
      content.id = "content";
      
      container.appendChild(content);

      document.body.appendChild(container);

      // ---------------------------------------------

      window.onkeydown = function(e) {
          var key = e.keyCode ? e.keyCode : e.which;

          /*
          // 16 = shift
          if (key == 16) {
             running = 1;
          }
          */

      }

      window.onkeyup = function(e) {
          var key = e.keyCode ? e.keyCode : e.which;

          // 27 = esc
          if (key == 27) {
            if(pause) 
              pause = false;
            else
              pause = true;
          }

          // 67 = c
          if(key == 67) {
            
          }

          /*
          // 16 = shift
          if (key == 16) {
            running = false;
          }
          */

          // 79 = o
          if (key == 79) {
            oculusEnabled = oculusEnabled ? false : true;
          }

          // 72 = h
          if (key == 72) {
            HUDEnabled = HUDEnabled ? false : true;
          }

      }

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      scene = new THREE.Scene();
      // scene.setGravity(new THREE.Vector3(0, -30, 0));

      // create a render, sets the background color and the size
      renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});
      renderer.setClearColor( 0xadadad, 1 );
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMapEnabled = true;

      // Here is the oculusRenderer for the Oculus Rift
        // worldScale 100 means that 100 Units == 1m
      oculusRenderer = new THREE.OculusRiftEffect( renderer, {worldScale: 100} );
      oculusRenderer.setSize( window.innerWidth, window.innerHeight );

      // create cameras.
      // camera is the normal camera and  will be controlled by FirstPersonControls.js/DK2Controls.js
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 30);

      // position and point the default camera to the center of the scene
      camera.position.x = -1.8;
      camera.position.z = 5.4;
      
      
      // --- hud
      // create a scene that will hold all hud elements and an ortho camera to always show them on top of the game scene
      HUDscene = new THREE.Scene();
      HUDcamera = new THREE.OrthographicCamera(-window.innerWidth, window.innerWidth, window.innerHeight, -window.innerHeight, 0.01, 100);

      HUD = new HUD(HUDscene, HUDisVisible, oculusEnabled);

      // lights
      light = new THREE.SpotLight(0xffa573);
      light.position.set(0, 10, 50);
      light.shadowCameraNear = 50;
      light.shadowMapWidth = 1024;
      light.shadowMapHeight = 1024;
      light.shadowCameraFar = 5000;
      light.castShadow = true;
      scene.add(light);

      var ambientLight = new THREE.AmbientLight( ambientLightColor );
      scene.add(ambientLight );

      // load scene model
      loader = new THREE.JSONLoader();
      loadScene();

      // debug controls
      setControls();
      // add fps stats
      addStats();

      /* web socket */
      socket.on('message',function(data){  

          if (data.pitch>0.7){
            if(!oculusEnabled)
              controls.moveForward = true ;
            else
              controls.wasd.up = true;

            walkingFactor = data.pitch/2;
            controls.lookSpeed = data.yaw/50;
          }else{
            if(!oculusEnabled)
              controls.moveForward = false ;
            else
              controls.wasd.up = false;

            walkingFactor = 0;
            controls.lookSpeed = data.yaw;
          }
      });

      // add the output of the renderer to the html element
      content.appendChild(renderer.domElement);

      // call the render function, after the first render, interval is determined by requestAnimationFrame
      render(0.016);
    }

    function setControls() {
      // Oculus DK2 controls
      if(oculusEnabled == true)
        controls = new THREE.DK2Controls(camera);
      else {
        controls = new THREE.FirstPersonControls(camera);
        controls.movementSpeed = 2;
        controls.lookSpeed = 0.00;
        controls.lookVertical = false;  //TODO true
      }
    }

    function degreesToRadians(degree){
        return degree*(Math.PI/180);
    }
    
    function render(dt) {

      // camera.updateProjectionMatrix();

      delta = clock.getDelta();
      controls.update(delta/MOVE_FACTOR);

      //lock the camera to height = 5
      camera.position.y = 5;
      // ---

      // //bind a cube in front of the camera NOT WORKING YET
      // var zCamVec = new THREE.Vector3(0,4,-5);
      // var pos = camera.localToWorld(zCamVec);
      // mesh.position.set(pos.x, pos.y, pos.z);
      // // mesh.lookAt(camera.position);


      // update HUD
      HUD.update(pause, mapX, mapY, sceneX, sceneZ, 0, 0, oculusEnabled);

      // update
      renderer.autoClear = false;
      if(oculusEnabled == true) {
        oculusRenderer.render( scene, camera, HUDscene);
      }
      else {
        // if we just switched to the normal renderer from the oculusRenderer, we have to reset the render area size
        renderer.setSize(window.innerWidth, window.innerHeight);

        renderer.clear();
        renderer.render(scene, camera);
        renderer.render(HUDscene, HUDcamera);
      }
      stats.update();
      requestAnimationFrame( render );      
    }

    var prevX = -10000, prevY = -10000;

    function addStats() {
      stats = new Stats();
      stats.setMode(0);
      stats.domElement.style.position = 'absolute';
      stats.domElement.style.left = '10px';
      stats.domElement.style.top = '10px';
      container.appendChild(stats.domElement);
    }

    //load the scene
    function loadScene() {
      loader.load("./models/market2.js",
      function(model, materials) {
        scene_mesh  = new THREE.Mesh( model,  new THREE.MeshFaceMaterial( materials ), 0 ); // the mass is 0
        scene_mesh.name = 'scene';
        scene_mesh.scale.x = 10;
        scene_mesh.scale.y = 10;
        scene_mesh.scale.z = 10; 
        scene_mesh.receiveShadow = true;
        scene_mesh.castShadow = true;
        scene.add(scene_mesh);
        // // i'm getting the scale factor here because 'scene_mesh' is loaded asynchronously       
      });
      loader.load("./models/cart.js",
      function(model, materials) {
        cart_mesh  = new THREE.Mesh( model,  new THREE.MeshFaceMaterial( materials ), 0 ); 
        cart_mesh.name = 'cart';
        cart_mesh.scale.x = 1;
        cart_mesh.scale.y = 1;
        cart_mesh.scale.z = 1;
        cart_mesh.receiveShadow = true;
        cart_mesh.castShadow = true;
        cart_mesh.position.y = 2.5;
        cart_mesh.position.set( 0, 0, - 3);
        scene.add(cart_mesh); 
      });
    }
    
    /**
     * Function handles the resize event. This make sure the camera and the renderer
     * are updated at the correct moment.
     */
    function handleResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        oculusRenderer.setSize( window.innerWidth, window.innerHeight );
        renderer.setSize(window.innerWidth, window.innerHeight);
    }     

    window.onload = init;
    // calls the handleResize function when the window is resized
    window.addEventListener('resize', handleResize, false);

  </script>

  </body>
</html>